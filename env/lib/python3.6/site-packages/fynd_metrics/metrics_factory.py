from __future__ import absolute_import
import re
from prometheus_client import Counter,Gauge,Histogram,Summary,Info,generate_latest,CONTENT_TYPE_LATEST

b = Counter("a_b","ab")


class MetricsObjectfactory(object):

    #Dict to store list of promethues metric objects created
    metric_object_factory = {}


    @classmethod
    def checkInstanace(cls,metrictype,metricname,metricdesc,metriclabel=[]):
        """Works like singleton pattern,generates new metric object if not exists in object dict"""
        if cls.metric_object_factory.get(metricname) is not None:
            return cls.metric_object_factory.get(metricname)
        else:
            #todo remove below if else if works fine for all promethues metric types
            # if metrictype is "Counter":
            #     new_object = Counter(metricname,metricdesc,metriclabel)
            #     cls.metric_object_factory.update({metricname: new_object})
            # elif metrictype is "Gauge":
            #     new_object = Gauge(metricname, metricdesc,metriclabel)
            #     cls.metric_object_factory.update({metricname: new_object})

            new_object = metrictype(metricname,metricdesc,metriclabel)
            cls.metric_object_factory.update({metricname: new_object})

            return new_object


    def generate_counter_object(self,metricname, metricdesc,metriclabel=[]):
        """Used to generate prometheus counter metric object"""
        try:
            MetricsObjectfactory.validate_metric_names(metricname)
            if len(metriclabel) != 0:
                MetricsObjectfactory.validate_metric_label(metriclabel)
            return MetricsObjectfactory.checkInstanace(Counter,metricname,metricdesc,metriclabel)
        except Exception as e:
            raise e

    def generate_histogram_object(self,metricname,metricdesc,metriclabel=[]):
        """Used to generate prometheus histogram metric object"""
        try:
            MetricsObjectfactory.validate_metric_names(metricname)
            if len(metriclabel) != 0:
                MetricsObjectfactory.validate_metric_label(metriclabel)
            return MetricsObjectfactory.checkInstanace(Histogram, metricname, metricdesc, metriclabel)
        except Exception as e:
            raise e

    def generate_summary_object(self,metricname,metricdesc,metriclabel=[]):
        """Used to generate prometheus summary metric object"""
        try:
            MetricsObjectfactory.validate_metric_names(metricname)
            if len(metriclabel) != 0:
                MetricsObjectfactory.validate_metric_label(metriclabel)
            return MetricsObjectfactory.checkInstanace(Summary, metricname, metricdesc, metriclabel)
        except Exception as e:
            raise e

    def generate_gauge_object(self,metricname, metricdesc,metriclabel=[]):
        """Used to generate prometheus gauge metric object"""
        try:
            MetricsObjectfactory.validate_metric_names(metricname)
            if len(metriclabel) != 0:
                MetricsObjectfactory.validate_metric_label(metriclabel)
            return MetricsObjectfactory.checkInstanace(Gauge, metricname, metricdesc, metriclabel)
        except Exception as e:
            raise e


    @classmethod
    def validate_metric_names(cls,metricname):
        """Used to validate metric names"""
        PROMETHEUS_VALID_NAMING_PATTERN = "[a-zA-Z_:][a-zA-Z0-9_:]*"
        if bool(re.match(PROMETHEUS_VALID_NAMING_PATTERN,metricname)) is False:
            raise Exception('Metric name is invalid')

    @classmethod
    def validate_metric_label(cls,metriclabel):
        """Used to validate label names"""
        PROMETHEUS_VALID_NAMING_PATTERN = "[a-zA-Z_][a-zA-Z0-9_]*"
        for labelstring in metriclabel:
            if bool(re.match(PROMETHEUS_VALID_NAMING_PATTERN,labelstring)) is False:
                raise Exception('Metric label is invalid')

    def get_pc(self):

        return generate_latest

