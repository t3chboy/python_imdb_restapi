from __future__ import absolute_import
import re,sys,traceback
from .Constants import *
from prometheus_client import Counter,Gauge,Histogram,Summary,Info,generate_latest,CONTENT_TYPE_LATEST
from fynd_exception import fynd_exception as fe

b = Counter("a_b","ab")


class MetricsObjectFactory(object):

    #Dict to store list of promethues metric objects created
    metric_object_store = {}


    @classmethod
    def check_instance(cls,metric_type,metric_name,metric_desc,metric_label=list()):
        """Works like singleton pattern,generates new metric object if not exists in object dict"""
        try:
            MetricsObjectFactory.validate_metric_names(metric_name)
            if not metric_label:
                MetricsObjectFactory.validate_metric_label(metric_label)

            if cls.metric_object_store.get(metric_name) is not None:
                return cls.metric_object_store.get(metric_name)
            else:
                new_metric_object = metric_type(metric_name,metric_desc,metric_label)
                cls.metric_object_store.update({metric_name: new_metric_object})
            return new_metric_object

        except fe.FyndCuctsomException as e:
            raise fe.FyndCuctsomException(e,traceback)



    def generate_counter_object(self,metric_name, metric_desc,metric_label=list()):
        """Used to generate prometheus counter metric object"""
        try:
            return MetricsObjectFactory.check_instance(Counter,metric_name,metric_desc,metric_label)
        except Exception as e:
            raise e

    def generate_histogram_object(self,metric_name,metric_desc,metric_label=list()):
        """Used to generate prometheus histogram metric object"""
        try:
            return MetricsObjectFactory.check_instance(Histogram, metric_name, metric_desc, metric_label)
        except Exception as e:
            raise e

    def generate_summary_object(self,metric_name,metric_desc,metric_label=list()):
        """Used to generate prometheus summary metric object"""
        try:
            return MetricsObjectFactory.check_instance(Summary, metric_name, metric_desc, metric_label)
        except Exception as e:
            raise e

    def generate_gauge_object(self,metric_name, metric_desc,metric_label=list()):
        """Used to generate prometheus gauge metric object"""
        try:
            return MetricsObjectFactory.check_instance(Gauge, metric_name, metric_desc, metric_label)
        except Exception as e:
            raise e

    @classmethod
    def validate_metric_names(cls,metric_name):
        """Used to validate metric names"""
        if not bool(re.match(PROMETHEUS_VALID_NAMING_PATTERN,metric_name)):
            raise Exception(INVALID_METRIC_NAME_EXCEPTION)

    @classmethod
    def validate_metric_label(cls,metric_label):
        """Used to validate metric label names"""
        for label_string in metric_label:
            if not bool(re.match(PROMETHEUS_VALID_NAMING_PATTERN,label_string)):
                raise Exception(INVALID_METRIC_LABEL_EXCEPTION)

    def get_pc(self):
        return generate_latest

